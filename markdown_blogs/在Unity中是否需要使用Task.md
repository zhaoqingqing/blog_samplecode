Unity本身是单线程的，比如Unity中的协程也是在单线程中进行调度的。

在其它线程中是无法访问Unity的API，对于需要与Unity进行交互的逻辑还是需要使用Unity的协程



## C#的Task

Unity2018升级了C# Runtime，在看完这篇文章《[Unity3d的Task存在的坑](https://zhuanlan.zhihu.com/p/86168785)》，我觉得在日常的逻辑开发中大多数情况是用不上Task，除非是纯数据方面的，原因如下：

应用需求场景不同，async/await在计算密集型/IO密集型需求下使用，因为这个是真的可以拿来写多线程并发优化。Unity本质还是个单线程，而且相关的协程还是其引擎层进行调度，和async这类更底层的异步编程还是有一定的区别。同时也因为Unity的单线程导致相关的API设计上不是线程安全的，所以即便Task.Run了一个跑在别的线程的任务也没法去用Unity的API。

综上也就是：如果觉得unity的一些IO操作效率不高/存在有类似复杂的寻路算法运算/自实现的ECS数据逻辑剥离解耦[只涉及到纯数据而无需直接和UI交互]的时候建议使用async/Task去实现来达成真正的并发优化，其他时候还是安心使用Unity本家的协程去做更合适。

顺带一提这也是Task不提供Abort的缘故，任务本身是个抽象概念，可以同步可以异步可以单线程也可以多线程，在多线程情况下一个线程不可能直接去强制终止另一个线程的运行---因为你们两同处一个层面；在单线程情况下你也不能终止自身，因此对于Task你需要准备一个CancellationToken 用作取消令牌并将其在启动相关任务的时候丢过去，然针对这个令牌执行取消【请求】,然后等那个Task的函数正常走完相关流程。协程那边本质上还是unity自己调度的一个周期性循环调用而且还是单线程，自然可以终止一个协程[放弃之后循环中执行]

